<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hologram Hand - Final Fix</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-container { position: absolute; bottom: 10px; right: 10px; width: 150px; border: 1px solid cyan; opacity: 0.3; transform: scaleX(-1); }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00f2ff; font-family: monospace; z-index: 100; text-align: center;
        }
        video { width: 100%; display: block; }
    </style>
</head>
<body>

<div id="loading">INICIALIZANDO BINARIOS WASM...<br>Por favor, espera.</div>
<div id="video-container"><video id="input_video" playsinline></video></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';

const loaderUI = document.getElementById('loading');
const videoElement = document.getElementById('input_video');

// --- CONFIGURACIÓN CRÍTICA PARA GITHUB PAGES ---
const handsMP = new Hands({
    locateFile: (file) => {
        // Forzamos la ruta absoluta al CDN para evitar el error de "waiting on dependencies"
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@${Hands.VERSION}/${file}`;
    }
});

handsMP.setOptions({
    maxNumHands: 2,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

// Callback cuando MediaPipe procesa resultados
handsMP.onResults(res => {
    if (loaderUI) loaderUI.style.display = 'none'; // Quitar texto de carga al detectar la mano
    updateHands(res.multiHandLandmarks);
});

// --- LÓGICA DE THREE.JS ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x00050a);
document.body.appendChild(renderer.domElement);
camera.position.z = 25;

// Objetos holográficos
const objects = [];
const createObj = () => {
    const g = new THREE.Group();
    const m = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 1), new THREE.MeshPhongMaterial({color: 0x00f2ff, wireframe: true, transparent: true, opacity: 0.4}));
    g.add(m);
    g.position.set((Math.random()-0.5)*15, (Math.random()-0.5)*10, -5);
    scene.add(g);
    return { mesh: g, grabbedBy: null };
};
objects.push(createObj(), createObj());
scene.add(new THREE.PointLight(0x00f2ff, 20, 100), new THREE.AmbientLight(0x111122));

// Manos Volumétricas (Simplificadas para estabilidad)
const handMeshes = [createHandMesh(), createHandMesh()];
function createHandMesh() {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(80000 * 3);
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ size: 0.04, color: 0x00f2ff, transparent: true, blending: THREE.AdditiveBlending });
    const mesh = new THREE.Points(geo, mat);
    scene.add(mesh);
    return { mesh, points: Array.from({length:21}, () => new THREE.Vector3()), isPinching: false, tracking: false };
}

function updateHands(landmarks) {
    handMeshes.forEach((h, i) => {
        if (landmarks && landmarks[i]) {
            h.tracking = true;
            landmarks[i].forEach((l, idx) => {
                h.points[idx].set((0.5-l.x)*30, (0.5-l.y)*18, -l.z*30);
            });
            h.isPinching = h.points[4].distanceTo(h.points[8]) < 2.5;
            h.mesh.material.opacity = 0.8;
            h.mesh.material.color.setHex(h.isPinching ? 0xff00ff : 0x00f2ff);
            
            // Lógica de inyectar volumen (Resumen rápido para la palma)
            const posAttr = h.mesh.geometry.attributes.position.array;
            for(let j=0; j<80000; j++) {
                const pIdx = Math.floor(Math.random()*21);
                const pNext = (pIdx + 1) % 21;
                const t = Math.random();
                posAttr[j*3] = THREE.MathUtils.lerp(h.points[pIdx].x, h.points[pNext].x, t) + (Math.random()-0.5);
                posAttr[j*3+1] = THREE.MathUtils.lerp(h.points[pIdx].y, h.points[pNext].y, t) + (Math.random()-0.5);
                posAttr[j*3+2] = THREE.MathUtils.lerp(h.points[pIdx].z, h.points[pNext].z, t) + (Math.random()-0.5);
            }
            h.mesh.geometry.attributes.position.needsUpdate = true;
        } else {
            h.tracking = false;
            h.mesh.material.opacity = 0;
        }
    });

    // Agarre de objetos
    objects.forEach(obj => {
        if (obj.grabbedBy) {
            if (!obj.grabbedBy.isPinching || !obj.grabbedBy.tracking) obj.grabbedBy = null;
            else obj.mesh.position.lerp(obj.grabbedBy.points[9], 0.2);
        } else {
            handMeshes.forEach(h => {
                if (h.tracking && h.isPinching && obj.mesh.position.distanceTo(h.points[8]) < 4) obj.grabbedBy = h;
            });
        }
    });
}

// Inicio de Cámara
const cameraHelper = new Camera(videoElement, {
    onFrame: async () => { await handsMP.send({image: videoElement}); },
    width: 1280, height: 720
});
cameraHelper.start();

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
